    <!-- GIT -->
    <section id="flutter" class="section text-center">
        <div style="padding-top:60px"></div>
		<div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h2 class="mkj-big-title">FLUTTER</h2>
                </div>
            </div>
        </div>
	</section>


	<!-- MENU -->
	<section id="resume" class="section  text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-4 text-left">
					<div class="mkj-menu"><a href="#" onclick="javascript: ouvrirlien('flutter_dart.html','FLUTTER');">Langage DART *</a></div>
					<div class="mkj-menu"><a href="#" onclick="javascript: ouvrirlien('flutter_widgets.html','FLUTTER');">Widgets *</a></div>
					<div class="mkj-menu"><a href="#commandes" class="smoothScroll">Commandes</a></div>
					<div class="mkj-menu"><a href="#dialog" class="smoothScroll">Dialogues</a></div>
				</div>
				<div class="col-md-4 text-left">
					<div class="mkj-menu"><a href="#pageroute" class="smoothScroll">Pages & Routes</a></div>
					<div class="mkj-menu"><a href="#http" class="smoothScroll">Requêtes HTTP</a></div>
					<div class="mkj-menu"><a href="#bdd" class="smoothScroll">Base de données</a></div>
					<div class="mkj-menu"><a href="#riverpod" class="smoothScroll">Riverpod</a></div>
				</div>
				<div class="col-md-4 text-left">
					<div class="mkj-menu"><a href="#cycle" class="smoothScroll">Cycle de vie app</a></div>
					<div class="mkj-menu"><a href="#splash" class="smoothScroll">Splash screen</a></div>
					<div class="mkj-menu"><a href="#branding" class="smoothScroll">Branding</a></div>
				</div>
			</div>
		</div>
		<div id="commandes"></div>
	</section>


	<!-- COMMANDES -->
	<section class="section  text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Commandes Flutter</h3>
					<p>
						<span class="mkj-high">flutter devices</span> Affiche la liste des devices visibles par Flutter.
						<br><span class="mkj-high">flutter run -d deviceId</span> Execute sur le device indiqué.
						<br><span class="mkj-high">flutter doctor </span> Vérifie que le setup de Flutter est correct.
						<br><span class="mkj-high">flutter upgrade </span> Met à jour Flutter à sa version la plus récente.
						<br><span class="mkj-high">flutter pub get </span> Met à jour la liste des dépendances. Nécessaires après un ajout d'import de package externe.
						<br><span class="mkj-high">flutter pub add shared_preferences </span> Ajoute le plugin SharedPreferences dans pubspec.yaml puis lance flutter pub get.
						<br><span class="mkj-high">flutter clean</span> Réinitialise les builds.
						<br><span class="mkj-high">flutter build appbundle --target-platform android-arm,android-arm64</span> Builde pour ARM avec optimization.
						<br><span class="mkj-high">flutter build apk --split-per-abi</span> Méthode recommandé pour release. Le APK se trouve dans H:\aketoo\build\app\outputs\flutter-apk.
						<br><span class="mkj-high">flutter --version</span> Affiche la version de flutter avec ses configs.
					</p>
					<br>
					<p>
						<u><b>Pour commencer un nouveau projet Flutter:</b></u>
						<ol>
							<li>Aller dans le dossier où le dossier du projet sera créé par Flutter.</li>
							<li><span class="mkj-high">flutter create my_app</span></li>
							<li><span class="mkj-high">cd my_app</span></li>
							<li><span class="mkj-high">flutter run</span> Exécute le projet ainsi créé.</li>
						</ol>
					</p>
					<br>
					<p>
						<u><b>Manipuler les simulateurs sur Android:</b></u>
						<br><span class="mkj-high">emulator -list-avds </span> Liste les émulateurs Android dispos.
						<br><span class="mkj-high">emulator -avd Nom_avd </span> Lancer l'émulateur Nom_avd.
					</p>
				</div>
			</div>
		</div>
		<div id="dialog"></div>
	</section>


    <!-- DIALOGUE -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Dialogues</h3>
					<p>
                        Afficher un toast (messages d'information affichés en bas de l'écran pendant quelques secondes)
						<pre class="mkj-code">
ScaffoldMessenger.of(context).showSnackBar(SnackBar(
    content: Text(loginController.text),
));
</pre>
                    </p>
					<br>
					<p>
						Afficher un dialogue simple
						<pre class="mkj-code">
showDialog(
    context: context,
    builder: (context) {
        return AlertDialog(
            content: Text(loginController.text),
        );
    },
);
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="pageroute"></div>
	</section>


    <!-- PAGES & ROUTES -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Pages & Routes</h3>
					<p>
						Il existe 2 méthodes pour naviguer dans les pages de Flutter:
						<br>- Les routes anonymes (à la volée)
						<br>- Les routes nommées
					</p>
					<br>
					<p>
						<span class="mkj-subtitle">Les routes à la volée</span>
						<br>Les routes anonymes sont rapides pour les apps simples mais présentent un risque de redondance pour les pages complexes. <span class="mkj-high">MaterialPageRoute</span> utilise l'animation native de la plateforme lors de l'affichage de la page cible. Le passage des paramètres entre pages se fait via le constructeur du widget page. Ici, il n'y a pas de notion d'arguments.
						<pre class="mkj-code">
Navigator.push(context, MaterialPageRoute<void>(
    builder: (BuildContext context) {
        return SecondePage(title: "Seconde page");
    }
));
</pre>
						Ou, plus simplement:
						<pre class="mkj-code">
Navigator.push(context, MaterialPageRoute(builder: (context) => const SecondePage()));
</pre>
						Pour revenir à la page précédente:
						<pre class="mkj-code">
Navigator.pop(context);
</pre>
                    </p>
					<br>
					<p>
						<span class="mkj-subtitle">Les routes nommées</span>
						<br>Les routes nommées permettant de définir la navigation dans l'app via un point central: dans la classe principale (ex: MyApp). Pour une app basée sur MaterialApp, celle-ci possède une propriété <span class="mkj-high">routes</span> de type Map&lt;String, WidgetBuilder&gt;. La clé est la route et la valeur est le widget de la page. <span class="mkj-high">InitialRoute</span> permet d'indiquer la route par défaut.
						<pre class="mkj-code">
return MaterialApp(
    title: 'Mon app Flutter',
    theme: theme,
    routes: {
        '/': (context) => MyHomePage(title: "Connexion"),
        '/secondPage': (context) => MySecondPage(title: "Deuxième page"),
    },
    initialRoute: '/',
);
</pre>
						Pour changer de page, il suffit d'appeler comme suit:
						<pre class="mkj-code">
Navigator.pushNamed(context, '/secondPage');
</pre>
						Pour revenir à la page précédente:
						<pre class="mkj-code">
Navigator.pop(context)
</pre>
						Il peut être nécessaire de passer des paramètres à l'ouverture de la nouvelle page. On utilise pour cela un argument optionnel arguments à Navigator.pushNamed.
						<pre class="mkj-code">
Navigator.pushNamed(context, '/secondPage',
    arguments: <String, String> {
        'title': "Deuxième page",
    },
);
</pre>
						En utilisant les paramètres, la route peut s'écrire simplement:
						<pre class="mkj-code">
routes: { ..., '/secondPage': (context) => MySecondPage(), }
</pre>
					</p>
					<br>
					<p>
						<span class="mkj-subtitle">ASTUCE:</span>
						<br>Utiliser <span class="mkj-high">Navigator.pushNamedAndRemoveUntil(...)</span> pour éviter que l'utilisateur puisse retourner à la page précédente. Utile après un login, par exemple.
					</p>
				</div>
			</div>
		</div>
		<div id="http"></div>
	</section>


	<!-- HTTP -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Requêtes HTTP</h3>
					<p>
						Pour pouvoir lancer une requête http vers un serveur, faire comme suit:
						<ol>
							<li>Ajouter le package http dans pubspec.yaml
								<pre class="mkj-code">
dependencies:
    flutter:
        sdk: flutter
    http:
</pre>
							</li>
							<li>Appliquer le changement sur terminal
								<pre class="mkj-code">flutter pub get</pre>
							</li>
							<li>Dans chaque script qui va utiliser http, importer le package:
								<pre class="mkj-code">import 'package:http/http.dart' as http;</pre>
							</li>
							<li>Puis utiliser comme suit, par exemple:
								<pre class="mkj-code">
final url = Uri.https(globals.baseUrl, 'app/confirmAccount/$confirmCode/$sessionId');
var response = await http.get(url);
final Map&lt;String, dynamic&gt; result = jsonDecode(response.body);
if (result['status'] == 'OK') { …. } else { … }
</pre>
							</li>
						</ol>
					</p>
					<br>
					<p>
						<span class="mkj-subtitle">ERREUR SSL SELF SIGNED (let's encrypt)</span>
						<br>Flutter refuse de se connecter sur un serveur auto-signé. La meilleure manière de corriger c'est d'avoir un certificat SSL. Mais on peut aussi contourner le problèmen en attendant.
						<br>
						<br>Dans main.dart, ajouter une classe qui override la création de session de http:
						<pre class="mkj-code">
class MyHttpOverrides extends HttpOverrides{
    @override
    HttpClient createHttpClient(SecurityContext? context){
        return super.createHttpClient(context)..badCertificateCallback = (X509Certificate cert, String host, int port) => host=='my.host.com';
    }
}
</pre>
						Puis ajouter dans la méthode main():
						<pre class="mkj-code">
void main() {
    HttpOverrides.global = MyHttpOverrides();
    runApp(const MyApp());
}
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="bdd"></div>
	</section>


	<!-- BASE DE DONNEES -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Base de données</h3>
					<p>
						Ci-après une méthode classique de traitement de données via <span class="mkj-high">SQFLITE</span>. A mettre dans une fichier database.dart, par exemple, puis à importer depuis les autres fichiers sources au besoin.
						<pre class="mkj-code">
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

class DB {
    static const DB_NAME = "mabase.db";
    static final DB_VERSION = 1;
    static final DB_TABLE = 'unetable';
    static final DB_COLUMN_ID = 'id';
    static final DB_COLUMN_VAL = 'val';

    <span class="mkj-comment">// créer une classe singleton</span>
    DB._privateConstructor();
    static final DB instance = DB._privateConstructor();

    <span class="mkj-comment">// partager un accè unique au database sur toute l'application</span>
    static Database? _database;
    Future<Database> get database async => _database ??= await _initDatabase();

    <span class="mkj-comment">// ouvre le database (ou le crééer si il n'existe pas encore)</span>
    Future<Database> _initDatabase() async {
        String path = join(await getDatabasesPath(), DB_NAME);
        return await openDatabase(path, version: DB_VERSION, onCreate: _onCreate);
    }

    <span class="mkj-comment">// initialisation structure de la base</span>
    Future _onCreate(Database db, int version) async {
        await db.execute("drop table if exists $DB_TABLE");
        await db.execute("create table $DB_TABLE ($DB_COLUMN_ID text primary key, $DB_COLUMN_VAL text)");
        await db.execute("insert into $DB_TABLE ($DB_COLUMN_ID, $DB_COLUMN_VAL) values ('uneligne', '')");
        await db.execute("insert into $DB_TABLE ($DB_COLUMN_ID, $DB_COLUMN_VAL) values ('uneautreligne', '')");
    }

    <span class="mkj-comment">// écrire une valeur dans une table</span>
    Future&lt;int&gt; setValeur(String valeur) async {
        Database db = await instance.database;
        return await db.update(DB_TABLE, {"val": user}, where: "id = ?", whereArgs: ["uneligne"]);
    }

    <span class="mkj-comment">// récupérer une valeur depuis une table</span>
    Future<String> getValeur() async {
        Database db = await instance.database;
        final results = await db.rawQuery("SELECT val FROM unetable WHERE id='uneligne'");
        return results[0]["val"].toString();
    }
}
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="cycle"></div>
	</section>


	<!-- CYCLE DE VIE APP -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Cycle de vie app</h3>
					<p>
					Savoir écouter les événèments qui surviennent durant le cycle de vie d'une app permet de faire des actions au moment où les changements surviennent. Par exemple, remettre automatiquement la sécurité lorsque l'app est mis en background.
					<br>Une manière de faire est d'utiliser le mixin <span class="mkj-high">WidgetsBindingObserver</span>.
					<br>La mise en place se fait en 4 étapes:
					<ol>
						<li>
							Lier le mixin au state de l'app pour indiquer qu'il l'observe
							<pre class="mkj-code">
class _MyAppState extends State&lt;MyApp&gt; <span class="mkj-motcle">with WidgetsBindingObserver</span> {
...
</pre>
						</li>
						<li>
							Lancer l'observation à l'initialisation
							<pre class="mkj-code">
@override
void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
}
</pre>
						</li>
						<li>
							Désactiver l'observation à la destruction
							<pre class="mkj-code">
@override
void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
}
</pre>
						</li>
						<li>
							Ecouter le callback <span class="mkj-high">didChangeAppLifecycleState</span>
							<pre class="mkj-code">
@override
void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused ) {
        ...
		<span class="mkj-comment">Etats: detached / inactive / hidden / paused / resumed / detached </span>
    }
}
</pre>
						</li>
					</ol>
					</p>
				</div>
			</div>
		</div>
		<div id="riverpod"></div>
	</section>


	<!-- RIVERPOD -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Riverpod state management</h3>
					<p>
						Utilisation de Riverpod:
						<ol>
							<li>Ajout de la dépendance Riverpod</li>
							<li>Prise en compte par l'application</li>
							<li>Usage via un StateProvider (facile)
								<ol>
									<li>Config de Riverpod</li>
									<li>Usage sur widget (ConsumerWidget, WidgetRef)</li>
									<li>Ecoute via Watch</li>
									<li>Edition via Read</li>
								</ol>
							</li>
							<li>Usage via un ChangeNotifierProvider (avancé)
								<ol>
									<li>Création modèle</li>
									<li>Config de Riverpod</li>
									<li>Usage sur widget (ConsumerWidget, WidgetRef)</li>
									<li>Ecoute via Watch</li>
									<li>Edition via Read</li>
								</ol>
							</li>
						</ol>
					</p>
					<p>
						<br><span class="mkj-subtitle">AJOUT DEPENDANCE RIVERPOD</span>
						<br>
						<br>Ajouter dans pubspec.yaml
						<pre class="mkj-code">
dependencies:
    flutter:
	    sdk: flutter
    <span class="mkj-motcle">flutter_riverpod: ^2.4.9</span>
</pre>
					</p>
					<p>
						<br><span class="mkj-subtitle">PRISE EN COMPTE PAR APP</span>
						<br>
						<br>Modifier main() pour englober l'app par ProviderScope
						<pre class="mkj-code">
void main() {
    runApp(
        <span class="mkj-motcle">const ProviderScope(</span>
            child: MyApp()
        <span class="mkj-motcle">),</span>
    );
}
</pre>
					</p>
					<p>
						<br><span class="mkj-subtitle">USAGE VIA STATEPROVIDER</span>
						<br>
						<br>StateProvider permet d'utiliser Riverpod via des states simples. Ceci s'applique généralement sur les données basiques.
						<br>
						<br>Configuration de Riverpod
						<pre class="mkj-code">
<span class="mkj-comment">//mettre dans fichier riverpod.dart par exemple</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'

final riverpod = StateProvider&lt;int&gt;((ref) {
    return 0;    <span class="mkj-comment">//valeur par défaut</span>
})
</pre>
						<br>Usage sur widget
						<pre class="mkj-code">
<span class="mkj-comment">//Il faut faire deux choses:</span>
<span class="mkj-comment">//  - Modifier StatelessWidget par ConsumerWidget</span>
<span class="mkj-comment">//  - Ajouter WidgetRef comme params dans build()</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'
class MaClasse extends <span class="mkj-motcle">ConsumerWidget</span> {
    const MaClass({super.key});

    @override
    Widget build(BuildContext context<span class="mkj-motcle">, WidgetRef ref</span>) {
        ...
	}
}
</pre>
						<br>Ecoute du notifier pour avoir la valeur du state
						<pre class="mkj-code">
Text(
    ref.<span class="mkj-motcle">watch(riverpod)</span>.toString(),    <span class="mkj-comment">//exemple affichant valeur 0</span>
    ...
)
</pre>
						<br>Edition du notifier pour modifier la valeur du state
						<pre class="mkj-code">
ElevatedButton.icon(
    onPressed: () {
        ref.<span class="mkj-motcle">read(riverpod.notifier).state</span>++;    <span class="mkj-comment">//exemple changement valeur de state</span>
    }
)
</pre>
					</p>
					<p>
						<br><span class="mkj-subtitle">USAGE VIA CHANGENOTIFIERPROVIDER</span>
						<br>
						<br>ChangeNotifierProvider permet d'utiliser Riverpod via des modèles.
						<br>
						<br>Création de modèle
						<pre class="mkj-code">
import 'package:flutter/material.dart'

class RiverpodModel extends <span class="mkj-motcle">ChangeNotifier</span> {
    int compteur;

    RiverpodModel({
        required this.compteur;
    });

    void incrementerCompteur() {
        compteur++;
        <span class="mkj-motcle">notifyListeners();</span>
    }
}
</pre>
						<br>Configuration de Riverpod
						<pre class="mkj-code">
<span class="mkj-comment">//mettre dans fichier riverpod.dart par exemple</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'

final riverpod = ChangeNotifierProvider&lt;RiverpodModel&gt;((ref) {
    return RiverpodModel(compteur: 0);    <span class="mkj-comment">//valeur par défaut</span>
})
</pre>
						<br>Usage sur widget
						<pre class="mkj-code">
<span class="mkj-comment">//Il faut faire deux choses:</span>
<span class="mkj-comment">//  - Modifier StatelessWidget par ConsumerWidget</span>
<span class="mkj-comment">//  - Ajouter WidgetRef comme params dans build()</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'
class MaClasse extends <span class="mkj-motcle">ConsumerWidget</span> {
    const MaClass({super.key});

    @override
    Widget build(BuildContext context<span class="mkj-motcle">, WidgetRef ref</span>) {
        ...
	}
}
</pre>
						<br>Ecoute du notifier pour avoir la valeur du state
						<pre class="mkj-code">
Text(
    ref.<span class="mkj-motcle">watch(riverpod)</span>.compteur.toString(),    <span class="mkj-comment">//exemple affichant valeur 0</span>
    ...
)
</pre>
						<br>Edition du notifier pour modifier la valeur du state
						<pre class="mkj-code">
ElevatedButton.icon(
    onPressed: () {
        ref.<span class="mkj-motcle">read(riverpod).incrementerCompteur()</span>;    <span class="mkj-comment">//exemple changement valeur modèle</span>
    }
)
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="splash"></div>
	</section>


    <!-- SPLASH -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Splash screen</h3>
					<p>
                        On peut utiliser le package <span class="mkj-high">flutter_native_splash</span> pour ajouter un splash screen natif sur Android et iOS, sans faire des changements manuels par plateforme. Le package va faire tous les changements pour vous.
                        <ol>
                            <li>Ajouter la dépendance dans pubspec.yaml
								<pre class="mkj-code">
dev_dependencies:
    flutter_native_splash: ^2.2.16 
</pre>
							</li>
                            <li>Appliquer le changement sur terminal
								<pre class="mkj-code">flutter pub get</pre>
							</li>
                            <li>Configurer le package dans pubspec.yaml
								<pre class="mkj-code">
flutter_native_splash:
    image: assets/images/splash.png
    color: 42a5f5
</pre>
							</li>
                            <li>Exécuter le package sur terminal
								<pre class="mkj-code">flutter pub run flutter_native_splash:create</pre>
							</li>
                        </ol>
                    </p>
				</div>
			</div>
		</div>
		<div id="branding"></div>
	</section>


	<!-- BRANDING -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">BRANDING</h3>
					<p>
						<span class="mkj-subtitle">Changer nom application</span>
						<br>Sur Android:
						<ol>
							<li>Aller dans <span class="mkj-high">android &gt; app &gt; src &gt; main</span></li>
							<li>Ouvrir <span class="mkj-high">AndroidManifest.xml</span></li>
							<li>Dans tag application, modifier le contenu de<span class="mkj-high">android:label</span></li>
							<li>Faire un <span class="mkj-high">flutter clean</span> sur le terminal</li>
							<li>Arrêter puis relancer l'app</li>
						</ol>
						Sur iOS:
						<ol>
							<li>Aller dans <span class="mkj-high">ios &gt; runner</span></li>
							<li>Ouvrir <span class="mkj-high">info.plist</span></li>
							<li>Trouver la clé <span class="mkj-high">CFBundleName</span> et modifier la valeur string (NJ: pareil pour CFBundleDisplayName).</li>
							<li>Faire un <span class="mkj-high">flutter clean</span> sur le terminal</li>
							<li>Arrêter puis relancer l'app</li>
						</ol>
						<br>
						<br>
						<span class="mkj-subtitle">Changer icône application (méthode alternative)</span>
						<ol>
							<li>Récupérer un fichier image du logo à utiliser avec une taille de 1024px x 1024px</li>
							<li>Aller sur <a href='appicon.co'>appicon.co</a>, et drag-and-drop le fichier sur l'espace prévu</li>
							<li>Sélectionner les plate-formes cibles des icônes (iphone, ipad, android, etc)</li>
							<li>Cliquer sur Génerate pour créer et télécharger les fichiers</li>
							<li>Dézipper le fichier appicons.zip généré</li>
							<li><span class="mkj-subtitle">Pour Android:</span></li>
							<li>Dans finder, aller dans le dossier (projet) > android > app > src > main > res</li>
							<li>Supprimer les dossiers mipmap***</li>
							<li>Copier dans le dossier les dossiers mipmap*** depuis (fichier dézippé) > android</li>
							<li><span class="mkj-subtitle">Pour iOS:</span></li>
							<li>Dans finder, aller dans le dossier (projet) > ios > runner</li>
							<li>Supprimer le dossier assets.xcassets</li>
							<li>Copier assets.xcassets depuis le dossier dézippé</li>
							<li>Arrêter et relancer l'app pour voir les changements</li>
						</ol>
						<br>
						<br>
						<span class="mkj-subtitle">Changer icône application (méthode alternative)</span>
						<ol>
							<li>Ajouter le package <span class="mkj-high">flutter_launcher_icons</span> dans dev_dependencies de pubspec.yaml
								<pre class="mkj-code">
dev_dependencies:
    flutter_launcher_icons: 
</pre>
							</li>
							<li>Ajouter la ligne referencant l'image préalablement ajouté dans le dossier
								<pre class="mkj-code">
flutter_icons:
    android: "launcher_icon"
    ios: true
    image_path: "assets/images/logo-mikajy-x4.png"
</pre>
							</li>
							<li>Appliquer
								<pre class="mkj-code">flutter pub run flutter_launcher_icons</pre>
							</li>
							<li>Arrêter l'app et relancer</li>
						</ol>
					</p>
				</div>
			</div>
		</div>
		<div style="padding-bottom:40px"></div>
	</section>
