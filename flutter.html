    <!-- GIT -->
    <section id="flutter" class="section text-center">
        <div style="padding-top:60px"></div>
		<div class="container">
            <div class="row">
                <div class="col-md-12">
                    <h2 class="mkj-big-title">FLUTTER</h2>
                </div>
            </div>
        </div>
	</section>


	<!-- MENU -->
	<section id="resume" class="section  text-center">
		<div class="container">
			<div class="row">
				<div class="col-sm-4 text-left">
					<div class="mkj-menu"><a href="#" onclick="javascript: ouvrirlien('flutter_dart.html','FLUTTER');">DART *</a></div>
					<div class="mkj-menu"><a href="#" onclick="javascript: ouvrirlien('flutter_widgets.html','FLUTTER');">Widgets *</a></div>
					<div class="mkj-menu"><a href="#commandes" class="smoothScroll">Commandes</a></div>
					<div class="mkj-menu"><a href="#dialog" class="smoothScroll">Dialogues</a></div>
				</div>
				<div class="col-sm-4 text-left">
					<div class="mkj-menu"><a href="#pageroute" class="smoothScroll">Pages & Routes</a></div>
					<div class="mkj-menu"><a href="#http" class="smoothScroll">Requêtes HTTP</a></div>
					<div class="mkj-menu"><a href="#bdd" class="smoothScroll">SQFLITE</a></div>
					<div class="mkj-menu"><a href="#riverpod" class="smoothScroll">Riverpod</a></div>
				</div>
				<div class="col-sm-4 text-left">
					<div class="mkj-menu"><a href="#cycle" class="smoothScroll">Cycle de vie app</a></div>
					<div class="mkj-menu"><a href="#splash" class="smoothScroll">Splash screen</a></div>
					<div class="mkj-menu"><a href="#branding" class="smoothScroll">Branding</a></div>
					<div class="mkj-menu"><a href="#play" class="smoothScroll">Play Store</a></div>
				</div>
			</div>
		</div>
		<div id="commandes">&nbsp;</div>
	</section>


	<!-- COMMANDES -->
	<section class="section  text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Commandes Flutter</h3>
					<p>
						<span class="mkj-high">flutter devices</span> Affiche la liste des devices visibles par Flutter.
						<br><span class="mkj-high">flutter run -d deviceId</span> Execute sur le device indiqué.
						<br><span class="mkj-high">flutter run -d deviceId --release</span> Execute sur le device et permet de le relancer même si débogueur est détaché du device physique
						<br><span class="mkj-high">flutter doctor </span> Vérifie que le setup de Flutter est correct.
						<br><span class="mkj-high">flutter upgrade </span> Met à jour Flutter à sa version la plus récente.
						<br><span class="mkj-high">flutter pub get </span> Met à jour la liste des dépendances. Nécessaires après un ajout d'import de package externe.
						<br><span class="mkj-high">flutter pub add shared_preferences </span> Ajoute le plugin SharedPreferences dans pubspec.yaml puis lance flutter pub get.
						<br><span class="mkj-high">flutter clean</span> Réinitialise les builds.
						<br><span class="mkj-high">flutter build appbundle --target-platform android-arm,android-arm64</span> Builde pour ARM avec optimization.
						<br><span class="mkj-high">flutter build apk --split-per-abi</span> Méthode recommandé pour release. Le APK se trouve dans H:\aketoo\build\app\outputs\flutter-apk.
						<br><span class="mkj-high">flutter --version</span> Affiche la version de flutter avec ses configs.
					</p>
					<br>
					<p>
						<u><b>Pour commencer un nouveau projet Flutter:</b></u>
						<ol>
							<li>Aller dans le dossier où le dossier du projet sera créé par Flutter.</li>
							<li><span class="mkj-high">flutter create my_app</span></li>
							<li><span class="mkj-high">cd my_app</span></li>
							<li><span class="mkj-high">flutter run</span> Exécute le projet ainsi créé.</li>
						</ol>
					</p>
					<br>
					<p>
						<u><b>Manipuler les simulateurs sur Android:</b></u>
						<br><span class="mkj-high">emulator -list-avds </span> Liste les émulateurs Android dispos.
						<br><span class="mkj-high">emulator -avd Nom_avd </span> Lancer l'émulateur Nom_avd.
					</p>
					<br>
					<p>
						<u><b>Changer la version de Java à utiliser (version 17) sur Mac M1:</b></u>
						<ol>
							<li>Télécharger le JDK depuis <a href="https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html">ce lien</a></li>
							<li>Mettre le path d'installation dans la variable d'environnement <b>JAVA_HOME</b>. Par défaut, le jdk est installé dans /Library/Java/JavaVirtualMachines/jdk-***</li>
							<li>Faire un: <b>flutter config --jdk-dir=$JAVA_HOME</b></li>
						</ol>
					</p>
				</div>
			</div>
		</div>
		<div id="dialog">&nbsp;</div>
	</section>


    <!-- DIALOGUE -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Dialogues</h3>
					<p>
                        Afficher un toast (messages d'information affichés en bas de l'écran pendant quelques secondes)
						<pre class="mkj-code">
ScaffoldMessenger.of(context).showSnackBar(SnackBar(
    content: Text(loginController.text),
));
</pre>
                    </p>
					<br>
					<p>
						Afficher un dialogue simple
						<pre class="mkj-code">
showDialog(
    context: context,
    builder: (context) {
        return AlertDialog(
            content: Text(loginController.text),
        );
    },
);
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="pageroute">&nbsp;</div>
	</section>


    <!-- PAGES & ROUTES -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Pages & Routes</h3>
					<p>
						Il existe 2 méthodes pour naviguer dans les pages de Flutter:
						<br>- Les routes anonymes (à la volée)
						<br>- Les routes nommées
					</p>
					<br>
					<p>
						<span class="mkj-subtitle">Les routes à la volée</span>
						<br>Les routes anonymes sont rapides pour les apps simples mais présentent un risque de redondance pour les pages complexes. <span class="mkj-high">MaterialPageRoute</span> utilise l'animation native de la plateforme lors de l'affichage de la page cible. Le passage des paramètres entre pages se fait via le constructeur du widget page. Ici, il n'y a pas de notion d'arguments.
						<pre class="mkj-code">
Navigator.push(context, MaterialPageRoute<void>(
    builder: (BuildContext context) {
        return SecondePage(title: "Seconde page");
    }
));
</pre>
						Ou, plus simplement:
						<pre class="mkj-code">
Navigator.push(context, MaterialPageRoute(builder: (context) => const SecondePage()));
</pre>
						Pour revenir à la page précédente:
						<pre class="mkj-code">
Navigator.pop(context);
</pre>
                    </p>
					<br>
					<p>
						<span class="mkj-subtitle">Les routes nommées</span>
						<br>Les routes nommées permettant de définir la navigation dans l'app via un point central: dans la classe principale (ex: MyApp). Pour une app basée sur MaterialApp, celle-ci possède une propriété <span class="mkj-high">routes</span> de type Map&lt;String, WidgetBuilder&gt;. La clé est la route et la valeur est le widget de la page. <span class="mkj-high">InitialRoute</span> permet d'indiquer la route par défaut.
						<pre class="mkj-code">
return MaterialApp(
    title: 'Mon app Flutter',
    theme: theme,
    routes: {
        '/': (context) => MyHomePage(title: "Connexion"),
        '/secondPage': (context) => MySecondPage(title: "Deuxième page"),
    },
    initialRoute: '/',
);
</pre>
						Pour changer de page, il suffit d'appeler comme suit:
						<pre class="mkj-code">
Navigator.pushNamed(context, '/secondPage');
</pre>
						Pour revenir à la page précédente:
						<pre class="mkj-code">
Navigator.pop(context)
</pre>
						Il peut être nécessaire de passer des paramètres à l'ouverture de la nouvelle page. On utilise pour cela un argument optionnel arguments à Navigator.pushNamed.
						<pre class="mkj-code">
Navigator.pushNamed(context, '/secondPage',
    arguments: <String, String> {
        'title': "Deuxième page",
    },
);
</pre>
						En utilisant les paramètres, la route peut s'écrire simplement:
						<pre class="mkj-code">
routes: { ..., '/secondPage': (context) => MySecondPage(), }
</pre>
					</p>
					<br>
					<p>
						<span class="mkj-subtitle">ASTUCE:</span>
						<br>Utiliser <span class="mkj-high">Navigator.pushNamedAndRemoveUntil(...)</span> pour éviter que l'utilisateur puisse retourner à la page précédente. Utile après un login, par exemple.
					</p>
				</div>
			</div>
		</div>
		<div id="http">&nbsp;</div>
	</section>


	<!-- HTTP -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Requêtes HTTP</h3>
					<p>
						Pour pouvoir lancer une requête http vers un serveur, faire comme suit:
						<ol>
							<li>Ajouter le package http dans pubspec.yaml
								<pre class="mkj-code">
dependencies:
    flutter:
        sdk: flutter
    http:
</pre>
							</li>
							<li>Appliquer le changement sur terminal
								<pre class="mkj-code">flutter pub get</pre>
							</li>
							<li>Dans chaque script qui va utiliser http, importer le package:
								<pre class="mkj-code">import 'package:http/http.dart' as http;</pre>
							</li>
							<li>Puis utiliser comme suit, par exemple:
								<pre class="mkj-code">
final url = Uri.https(globals.baseUrl, 'app/confirmAccount/$confirmCode/$sessionId');
var response = await http.get(url);
final Map&lt;String, dynamic&gt; result = jsonDecode(response.body);
if (result['status'] == 'OK') { …. } else { … }
</pre>
							</li>
						</ol>
					</p>
					<br>
					<p>
						<span class="mkj-subtitle">ERREUR SSL SELF SIGNED (let's encrypt)</span>
						<br>Flutter refuse de se connecter sur un serveur auto-signé. La meilleure manière de corriger c'est d'avoir un certificat SSL. Mais on peut aussi contourner le problèmen en attendant.
						<br>
						<br>Dans main.dart, ajouter une classe qui override la création de session de http:
						<pre class="mkj-code">
class MyHttpOverrides extends HttpOverrides{
    @override
    HttpClient createHttpClient(SecurityContext? context){
        return super.createHttpClient(context)..badCertificateCallback = (X509Certificate cert, String host, int port) => host=='my.host.com';
    }
}
</pre>
						Puis ajouter dans la méthode main():
						<pre class="mkj-code">
void main() {
    HttpOverrides.global = MyHttpOverrides();
    runApp(const MyApp());
}
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="bdd">&nbsp;</div>
	</section>


	<!-- SQFLITE -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Base de données</h3>
					<p>
						Une manière de persister les données dans Flutter est d'utiliser la base de données <span class="mkj-high">SQFLITE</span>. Avant d'utiliser SQFLITE, il faut ajouter les dépendances <span class="mkj-high">sqflite</span> et <span class="mkj-high">path</span> (pour l'accès aux fichiers) dans pubsepc.yaml, puis lancer <span class="mkj-high">flutter pub get</span>.
						<pre class="mkj-code">
<span class="mkj-comment">/** Fichier: pubspec.yaml **/</span>
dependencies:
  sqflite:
  path:
</pre>
						<p>Ci-après une méthode classique de traitement de données via <span class="mkj-high">SQFLITE</span>. A mettre dans une fichier database.dart, par exemple, puis à importer depuis les autres fichiers sources au besoin.</p>
						<pre class="mkj-code">
<span class="mkj-comment">/** Fichier: database.dart **/</span>
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

class DB {
    static const DB_NAME = "mabase.db";
    static final DB_VERSION = 1;
    static final DB_TABLE = 'unetable';
    static final DB_COLUMN_ID = 'id';
    static final DB_COLUMN_VAL = 'val';

    <span class="mkj-comment">// créer une classe singleton</span>
    DB._privateConstructor();
    static final DB instance = DB._privateConstructor();

    <span class="mkj-comment">// partager un accè unique au database sur toute l'application</span>
    static Database? _database;
    Future<Database> get database async => _database ??= await _initDatabase();

    <span class="mkj-comment">// ouvre le database (ou le crééer si il n'existe pas encore)</span>
    Future<Database> _initDatabase() async {
        String path = join(await getDatabasesPath(), DB_NAME);
        return await openDatabase(path, version: DB_VERSION, onCreate: _onCreate);
    }

    <span class="mkj-comment">// initialisation structure de la base</span>
    Future _onCreate(Database db, int version) async {
        await db.execute("drop table if exists $DB_TABLE");
        await db.execute("create table $DB_TABLE ($DB_COLUMN_ID text primary key, $DB_COLUMN_VAL text)");
        await db.execute("insert into $DB_TABLE ($DB_COLUMN_ID, $DB_COLUMN_VAL) values ('uneligne', '')");
        await db.execute("insert into $DB_TABLE ($DB_COLUMN_ID, $DB_COLUMN_VAL) values ('uneautreligne', '')");
    }

    <span class="mkj-comment">// écrire une valeur dans une table</span>
    Future&lt;int&gt; setValeur(String valeur) async {
        Database db = await instance.database;
        return await db.update(DB_TABLE, {"val": user}, where: "id = ?", whereArgs: ["uneligne"]);
    }

    <span class="mkj-comment">// récupérer une valeur depuis une table</span>
    Future<String> getValeur() async {
        Database db = await instance.database;
        final results = await db.rawQuery("SELECT val FROM unetable WHERE id='uneligne'");
        return results[0]["val"].toString();
    }
}
</pre>
					<p>Les méthodes s'utilisent après comme suit dans les autres fichiers:</p>
					<pre class="mkj-code">
import 'src/database.dart';

class _MyAppState extends State&lt;MyApp&gt; {

    final db = DB.instance;

    @override
    void initState() {
        super.initState();
        () async {  <span class="mkj-comment">// nécessaire si appel dans une méthode non async</span>
            await Future.delayed(const Duration(seconds: 1));  <span class="mkj-comment">// pour cet exemple seulement, dans un initState()</span>
            var dbval = await db.getValeur();
            ...
        }();
    }
}
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="cycle">&nbsp;</div>
	</section>


	<!-- CYCLE DE VIE APP -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Cycle de vie app</h3>
					<p>
					Savoir écouter les événèments qui surviennent durant le cycle de vie d'une app permet de faire des actions au moment où les changements surviennent. Par exemple, remettre automatiquement la sécurité lorsque l'app est mis en background.
					<br>Une manière de faire est d'utiliser le mixin <span class="mkj-high">WidgetsBindingObserver</span>.
					<br>La mise en place se fait en 4 étapes:
					<ol>
						<li>
							Lier le mixin au state de l'app pour indiquer qu'il l'observe
							<pre class="mkj-code">
class _MyAppState extends State&lt;MyApp&gt; <span class="mkj-motcle">with WidgetsBindingObserver</span> {
...
</pre>
						</li>
						<li>
							Lancer l'observation à l'initialisation
							<pre class="mkj-code">
@override
void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
}
</pre>
						</li>
						<li>
							Désactiver l'observation à la destruction
							<pre class="mkj-code">
@override
void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
}
</pre>
						</li>
						<li>
							Ecouter le callback <span class="mkj-high">didChangeAppLifecycleState</span>
							<pre class="mkj-code">
@override
void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused ) {
        ...
		<span class="mkj-comment">Etats: detached / inactive / hidden / paused / resumed / detached </span>
    }
}
</pre>
						</li>
					</ol>
					</p>
				</div>
			</div>
		</div>
		<div id="riverpod">&nbsp;</div>
	</section>


	<!-- RIVERPOD -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Riverpod state management</h3>
					<p>
						Utilisation de Riverpod:
						<ol>
							<li>Ajout de la dépendance Riverpod</li>
							<li>Prise en compte par l'application</li>
							<li>Usage via un StateProvider (facile)
								<ol>
									<li>Config de Riverpod</li>
									<li>Usage sur widget (ConsumerWidget, WidgetRef)</li>
									<li>Ecoute via Watch</li>
									<li>Edition via Read</li>
								</ol>
							</li>
							<li>Usage via un ChangeNotifierProvider (avancé)
								<ol>
									<li>Création modèle</li>
									<li>Config de Riverpod</li>
									<li>Usage sur widget (ConsumerWidget, WidgetRef)</li>
									<li>Ecoute via Watch</li>
									<li>Edition via Read</li>
								</ol>
							</li>
						</ol>
					</p>
					<p>
						<br><span class="mkj-subtitle">AJOUT DEPENDANCE RIVERPOD</span>
						<br>
						<br>Ajouter dans pubspec.yaml
						<pre class="mkj-code">
dependencies:
    flutter:
	    sdk: flutter
    <span class="mkj-motcle">flutter_riverpod: ^2.4.9</span>
</pre>
					</p>
					<p>
						<br><span class="mkj-subtitle">PRISE EN COMPTE PAR APP</span>
						<br>
						<br>Modifier main() pour englober l'app par ProviderScope
						<pre class="mkj-code">
void main() {
    runApp(
        <span class="mkj-motcle">const ProviderScope(</span>
            child: MyApp()
        <span class="mkj-motcle">),</span>
    );
}
</pre>
					</p>
					<p>
						<br><span class="mkj-subtitle">USAGE VIA STATEPROVIDER</span>
						<br>
						<br>StateProvider permet d'utiliser Riverpod via des states simples. Ceci s'applique généralement sur les données basiques.
						<br>
						<br>Configuration de Riverpod
						<pre class="mkj-code">
<span class="mkj-comment">//mettre dans fichier riverpod.dart par exemple</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'

final riverpod = StateProvider&lt;int&gt;((ref) {
    return 0;    <span class="mkj-comment">//valeur par défaut</span>
})
</pre>
						<br>Usage sur widget
						<pre class="mkj-code">
<span class="mkj-comment">//Il faut faire deux choses:</span>
<span class="mkj-comment">//  - Modifier StatelessWidget par ConsumerWidget</span>
<span class="mkj-comment">//  - Ajouter WidgetRef comme params dans build()</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'
class MaClasse extends <span class="mkj-motcle">ConsumerWidget</span> {
    const MaClass({super.key});

    @override
    Widget build(BuildContext context<span class="mkj-motcle">, WidgetRef ref</span>) {
        ...
	}
}
</pre>
						<br>Ecoute du notifier pour avoir la valeur du state
						<pre class="mkj-code">
Text(
    ref.<span class="mkj-motcle">watch(riverpod)</span>.toString(),    <span class="mkj-comment">//exemple affichant valeur 0</span>
    ...
)
</pre>
						<br>Edition du notifier pour modifier la valeur du state
						<pre class="mkj-code">
ElevatedButton.icon(
    onPressed: () {
        ref.<span class="mkj-motcle">read(riverpod.notifier).state</span>++;    <span class="mkj-comment">//exemple changement valeur de state</span>
    }
)
</pre>
					</p>
					<p>
						<br><span class="mkj-subtitle">USAGE VIA CHANGENOTIFIERPROVIDER</span>
						<br>
						<br>ChangeNotifierProvider permet d'utiliser Riverpod via des modèles.
						<br>
						<br>Création de modèle
						<pre class="mkj-code">
import 'package:flutter/material.dart'

class RiverpodModel extends <span class="mkj-motcle">ChangeNotifier</span> {
    int compteur;

    RiverpodModel({
        required this.compteur;
    });

    void incrementerCompteur() {
        compteur++;
        <span class="mkj-motcle">notifyListeners();</span>
    }
}
</pre>
						<br>Configuration de Riverpod
						<pre class="mkj-code">
<span class="mkj-comment">//mettre dans fichier riverpod.dart par exemple</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'

final riverpod = ChangeNotifierProvider&lt;RiverpodModel&gt;((ref) {
    return RiverpodModel(compteur: 0);    <span class="mkj-comment">//valeur par défaut</span>
})
</pre>
						<br>Usage sur widget
						<pre class="mkj-code">
<span class="mkj-comment">//Il faut faire deux choses:</span>
<span class="mkj-comment">//  - Modifier StatelessWidget par ConsumerWidget</span>
<span class="mkj-comment">//  - Ajouter WidgetRef comme params dans build()</span>
import 'package: flutter_riverpod/flutter_riverpod.dart'
class MaClasse extends <span class="mkj-motcle">ConsumerWidget</span> {
    const MaClass({super.key});

    @override
    Widget build(BuildContext context<span class="mkj-motcle">, WidgetRef ref</span>) {
        ...
	}
}
</pre>
						<br>Ecoute du notifier pour avoir la valeur du state
						<pre class="mkj-code">
Text(
    ref.<span class="mkj-motcle">watch(riverpod)</span>.compteur.toString(),    <span class="mkj-comment">//exemple affichant valeur 0</span>
    ...
)
</pre>
						<br>Edition du notifier pour modifier la valeur du state
						<pre class="mkj-code">
ElevatedButton.icon(
    onPressed: () {
        ref.<span class="mkj-motcle">read(riverpod).incrementerCompteur()</span>;    <span class="mkj-comment">//exemple changement valeur modèle</span>
    }
)
</pre>
					</p>
				</div>
			</div>
		</div>
		<div id="splash">&nbsp;</div>
	</section>


    <!-- SPLASH -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">Splash screen</h3>
					<p>
                        On peut utiliser le package <span class="mkj-high">flutter_native_splash</span> pour ajouter un splash screen natif sur Android et iOS, sans faire des changements manuels par plateforme. Le package va faire tous les changements pour vous.
                        <ol>
                            <li>Ajouter la dépendance dans pubspec.yaml
								<pre class="mkj-code">
dev_dependencies:
    flutter_native_splash: ^2.2.16 
</pre>
							</li>
                            <li>Appliquer le changement sur terminal
								<pre class="mkj-code">flutter pub get</pre>
							</li>
                            <li>Configurer le package dans pubspec.yaml
								<pre class="mkj-code">
flutter_native_splash:
    image: assets/images/splash.png
    color: 42a5f5
</pre>
							</li>
                            <li>Exécuter le package sur terminal
								<pre class="mkj-code">flutter pub run flutter_native_splash:create</pre>
							</li>
                        </ol>
                    </p>
				</div>
			</div>
		</div>
		<div id="branding">&nbsp;</div>
	</section>


	<!-- BRANDING -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">BRANDING</h3>
					<p>
						<span class="mkj-subtitle">Changer nom application</span>
						<br>Sur Android:
						<ol>
							<li>Aller dans <span class="mkj-high">android &gt; app &gt; src &gt; main</span></li>
							<li>Ouvrir <span class="mkj-high">AndroidManifest.xml</span></li>
							<li>Dans tag application, modifier le contenu de<span class="mkj-high">android:label</span></li>
							<li>Faire un <span class="mkj-high">flutter clean</span> sur le terminal</li>
							<li>Arrêter puis relancer l'app</li>
						</ol>
						Sur iOS:
						<ol>
							<li>Aller dans <span class="mkj-high">ios &gt; runner</span></li>
							<li>Ouvrir <span class="mkj-high">info.plist</span></li>
							<li>Trouver la clé <span class="mkj-high">CFBundleName</span> et modifier la valeur string (NJ: pareil pour CFBundleDisplayName).</li>
							<li>Faire un <span class="mkj-high">flutter clean</span> sur le terminal</li>
							<li>Arrêter puis relancer l'app</li>
						</ol>
						<br>
						<br>
						<span class="mkj-subtitle">Changer icône application (méthode alternative)</span>
						<ol>
							<li>Récupérer un fichier image du logo à utiliser avec une taille de 1024px x 1024px</li>
							<li>Aller sur <a href='https://www.appicon.co/' target="_blank">appicon.co</a>, et drag-and-drop le fichier sur l'espace prévu</li>
							<li>Sélectionner les plate-formes cibles des icônes (iphone, ipad, android, etc)</li>
							<li>Cliquer sur Génerate pour créer et télécharger les fichiers</li>
							<li>Dézipper le fichier appicons.zip généré</li>
							<li><span class="mkj-subtitle">Pour Android:</span></li>
							<li>Dans finder, aller dans le dossier (projet) > android > app > src > main > res</li>
							<li>Supprimer les dossiers mipmap***</li>
							<li>Copier dans le dossier les dossiers mipmap*** depuis (fichier dézippé) > android</li>
							<li><span class="mkj-subtitle">Pour iOS:</span></li>
							<li>Dans finder, aller dans le dossier (projet) > ios > runner</li>
							<li>Supprimer le dossier assets.xcassets</li>
							<li>Copier assets.xcassets depuis le dossier dézippé</li>
							<li>Arrêter et relancer l'app pour voir les changements</li>
						</ol>
						<br>
						<br>
						<span class="mkj-subtitle">Changer icône application (méthode alternative)</span>
						<ol>
							<li>Ajouter le package <span class="mkj-high">flutter_launcher_icons</span> dans dev_dependencies de pubspec.yaml
								<pre class="mkj-code">
dev_dependencies:
    flutter_launcher_icons: 
</pre>
							</li>
							<li>Ajouter la ligne referencant l'image préalablement ajouté dans le dossier
								<pre class="mkj-code">
flutter_icons:
    android: "launcher_icon"
    ios: true
    image_path: "assets/images/logo-mikajy-x4.png"
</pre>
							</li>
							<li>Appliquer
								<pre class="mkj-code">flutter pub run flutter_launcher_icons</pre>
							</li>
							<li>Arrêter l'app et relancer</li>
						</ol>
					</p>
				</div>
			</div>
		</div>
		<div id="play">&nbsp;</div>
	</section>


	<!-- PLAY STORE -->
	<section class="section text-center">
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-left">
					<h3 class="mkj-title">DEPLOYER SUR PLAY STORE</h3>
					<p>
						<b>Signer l'application</b>
						<ol>
							<li>
								Créer une clé "keystore" (sur mac)
								<ol>
									<li>Exécuter la commande ci-après: <pre>keytool -genkey -v -keystore ~/upload-keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias upload</pre>
									<li>Créer un fichier <b>key.properties</b> dans le dossier projet &gt; android</li>
									<li>Ajouter le contenu ci-après dans le fichier key.properties, changer "LeMotDePasseSaisiePlusHaut" par le mot de passe:
										<pre>
storePassword=LeMotDePasseSaisiePlusHaut
keyPassword=LeMotDePasseSaisiePlusHaut
keyAlias=upload
storeFile=/Users/utilisateur/upload-keystore.jks
										</pre>
									</li>
									<li><span style='color:red'>Important! ajouter le fichier key.properties dans .gitignore</span></li>
									<li>Editer le fichier <b>build.gradle</b> dans le dossier projet &gt; android &gt; app:
										<pre>
<c>//Ajouter avant la propriété android {</c>
def keystoreProperties = new Properties()
def keystorePropertiesFile = rootProject.file('key.properties')
if (keystorePropertiesFile.exists()) {
    keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
}

<c>//Supprimer la signature pour le debug dans la propriété buildTypes { release {</c>
signingConfig = signingConfigs.debug

<c>//Remplacer par:</c>
signingConfig = signingConfigs.release
</pre>
									</li>
									<li>Faire un: <pre>
flutter clean
flutter pub get
</pre>
									<li>Créer un release bundle<pre>flutter build appbundle</pre>
										<br>Le bundle est généré dans: [project]/build/app/outputs/bundle/release/app-release.aab
									</li>
								</ol>
							</li>
						</ol>
					</p>
					<p>
						Pour une complète référence, suivre les indications sur <a href="https://docs.flutter.dev/deployment/android" target="_blank">https://docs.flutter.dev/deployment/android</a>
					</p>
				</div>
			</div>
		</div>
		<div style="padding-bottom:40px"></div>
	</section>